# 锁

当多个协程间使用到了相同内存空间中的变量时，有可能出现同时对数据进行读写的情况，这时可能会导致数据不准确，打个比方：

用户A和用户B是一对夫妻，两人共同使用着一张银行卡，卡中余额为50000元。碰巧有一天，用户A正将6000元工资存入银行，在同一时刻用户B支出了500元购买衣物，两笔操作同时发生。

按照正常逻辑，要么是先存入后支出，余额为50000+6000-500=55500，要么是先支出后存入50000-500+6000=55500，这两种方式都不会有问题。但在程序执行的过程中，这两笔操作是不具备原子性的，都要对数据先读后写，分两步才能完成。有可能A的操作刚读出数据还未写入时，B的操作完成了读写，之后A的写操作才完成，这样B的操作就被无效了，余额为50000+6000=56000元；也有可能B的操作刚读出数据还未写入时，A的操作完成了读写，之后B的写操作才完成，这样A的操作就被无效了，余额变为50000-500=49500元。为了解决类似问题，程序中处理的过程中需要引入锁机制，用来保证数据并发读写时的准确性。

锁可以分很多种，对于分布式系统可以有分布式锁，对于线程可以有线程锁，对于协程也可以有协程锁。

在golang内置的sync库中实现了协程锁

